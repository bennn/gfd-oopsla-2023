


This work touches a range of existing strands of research. At
the object-level, the main motivation for this paper is prior research on
the performance issues of sound gradual typing; while two significant
sources of inspiration are research on gradual type migration and
profiling technique.  At the meta-level, this work builds on and extends
prior results on the rational programmer method.   

\paragraph{The Rational Programmer}

 \citet{lksfd-popl-2020,lgfd-icfp-2021} propose the rational programmer as
 an empirical method for evaluating the role of blame in debugging
 different kinds of logical mistakes with software contracts and gradual types. However,
 the ideas behind the rational programmer go beyond debugging logical
 mistakes. In essence, the rational programmer is a general methodological
 framework for the systematic investigation of the pragmatics of
 programming languages and tool, i.e., the value of the various aspects of a
 language or a tool in the context of a specific task. In that sense,
 Lazarek et al.'s work focuses on a single context: debugging logical
 mistakes. This work shows how the rational programmer applies to
 another context: performance tuning and debugging of performance
 bottlenecks. Hence, it shares the language features
 it studies, gradual typing, with Lazarek's work, but it looks at a different aspect of its
 pragmatics. As a result besides contributing to the understanding of the
 value of gradual types, it also provides evidence for the generality of
 the rational programmer method itself.  

\paragraph{Performance Tuning and Gradual Typing} 

\citet{gtnffvf-jfp-2019} give definite proof of
the grim performance problems of deep
gradual types; adding deep types to just a few components 
can make a program prohibitively slow, and it may take
adding deep types to almost every component for performance to get back to
an acceptable level. This observation sets the stage for the work in this
paper; the experimental approach of Greenman et al. provides
the benchmarks and the migration lattices that are key elements of the
rational programmer experiment herein.  

Even before Greenman et al.'s empirical results however, the research
community on gradual typing had observed the negative impact of deep types
on time and space program performance, and had looked for ways to mitigate
it.  Roughly, the mitigation approaches fall in two groups. The first
group proposes the design of alternative run-time checking strategies that
aim to control the running time and space cost of checks while providing
some soundness guarantees (e.g.
~\citep{grmhn-vmil-2019,sgt-esop-2009,rmhn-ecoop-2019,glfd-pj-2022,lgmvpk-pj-2023,svctg-esop-2015,rat-oopsla-2017,sfrbcsb-popl-2014,rsfbv-popl-2015,coersion-passing-style}).
From these different strategies, the transient
strategy~\cite{vksb-dls-2014,vss-popl-2017,v-thesis-2019} and its
so-called shallow types play an important role in this work (see
section~\ref{sec:seascape}).  ~\citet{type-untyped} provide a
comprehensive analysis and comparison of the different points of the
overall checking strategy landscape.

The second group of mitigation approaches targets the time and space optimization of
existing checking strategies by removing unnecessary
checks~\cite{collapsible,corpse-reviver, kas-pldi-2019,grmhn-vmil-2019,
rat-oopsla-2017,pycket,bbst-oopsla-2017}. While this is a promising line
of work, some of the proposed techniques focus on specific pathologies,
while others do not scale yet to full-fledged production languages.
Hence, the problem of performant sound gradual typing is still largely
open.   

Indeed, exactly because of this open problem, many existing language
designs exhibit a hybrid approach when it comes to the kind of gradual
checks they perform. For instance, Thorn and StrongScript use a mixture of
optional types and so-called concrete
types~\citep{wzlov-popl-2010,rzv-ecoop-2015}. The first result in no
run-time checks (same as TypeScript's unsound types), while the second
perform cheap nominal type checking but limit the values that components
can exchange.  As a way to ease this expressiveness issue, Static Python
combines deep with concrete types~\citep{lgmvpk-pj-2023}.  Pyret uses deep
checks for fixed-size data and shallow checks for recursive data and
functions.  Older versions of
\href{https://medium.com/dartlang/dart-2-stable-and-the-dart-web-platform-3775d5f8eac7}{Dart}
allowed developers to switch between  deep and optional types.
Following~\citet{g-deep-shallow}'s work, Typed Racket's recent versions
offer to programmers a choice between deep and shallow checks. The work in
this paper investigates this latter hybrid setting. 

\paragraph{Gradual Type Migration} Besides laying bare the performance
issues of sound gradual typing, \citet{gtnffvf-jfp-2019}'s result show
that a programmer who persists with migration eventually reverts the
negative impact of adding types to a code base. In fact, in many cases,
the programmer can even manage to unlock type-driven optimizations that
make a typed code base more performant than its untyped counterpart. This
insight offers the justification for the behavior of the rational
programmers in this paper. 

Research on gradual type migration can be split in three broad directions:
static techniques~\cite{rch:in-out-infer-gt, km:ts-type-evo,
mp:gt-decidable, ccew:gt-migrate, gc:gt-infer,
cagg-solver-based-migration,clps-popl-2020,js-infer,ruby-static-infer,unif-infer};
dynamic
ones~\cite{msi:gt-infer-hm,dyn-infer-ruby,profile-guided-typing,jstrace},
and those based on machine learning
(ML)~\cite{lambdanet,nl2ptype,learn-types-big-data,ml-ts}. The latter are
the ones that have provided so far the most scalable results as they can
produce accurate annotations for a range of Javascript components in the
wild. However, as the authors of the latest ML-based work note
``automatically predicting type annotations is a challenging task and much
work remains to be done.''
 
\paragraph{Performance Tuning with Profilers}

grmhn-vmil-2019;
profiling strategy for transient: run once for each type, set of hot types => hot config;
mention too when discussing FSP for transient






