%% -----------------------------------------------------------------------------
From the perspective of the experiment, every program \program{} is a
collection of interacting components $\component$. Specifically, some
components have deep types, some  have shallow, and some  have no types at
all. Independently of their types, a component $\component{}_1$, may import
another component $\component{}_2$  which establishes a
\emph{boundary} between them through which they exchange values at
run-time. As section~\ref{sec:seascape} describes, depending on the kind of types at
the two sides of the boundary, a value exchange can result in checks,
which may affect negatively the performance of \program{}. 

 Since boundaries are the source of performance degradation, a profiling
 strategy aims to change the types of components in order to eliminate a
 boundary in a program, hopefully the most costly one. In formal terms, a
 profiling strategy is a function that consumes a program \program{} and
 returns a set of pairs $(\component{}, \type{})$ where \type{} is either
 \deep{} or \shallow{}. Each pair
 prescribes a modification for \program{}. For instance, if a strategy
 returns the singleton set with the pair $(a, \deep)$, then the strategy
 directs its rational-programmer mode to equip component $a$ with deep
 types, or to toggle to deep its existing types, if $a$ is already typed.
 Of course, if a component has already the prescribed kind of types, the
 modification does not affect it. Finally, the strategy returns the empty
 set when it cannot determine a modification.

 Overall, the experiment compares rational-programmer modes
 derived from 6 basic strategies. Figure~\ref{f:bstrategies}
 lists them along with their descriptions.

 At a first level, the basic strategies differ in whether they produce their
 result by analyzing the feedback of a \featkw{} or a \statkw{} profiler.
 Those that use the first kind of profiler identify directly the most
 costly boundary in \program{}, and produce modifications of the
 components at either side.  Those that use the second cannot directly
 identify a boundary.  Instead they detect the most costly component
 $\component{}_1$ in terms of either \selfkw{} or \totalkw{} time.  Then,
 they pick  one of the boundaries between $\component{}_1$ and the components it
 imports or import it.  Specifically, the strategies pick a boundary
 between $\component{}_1$ and a component $\component{}_2$ where
 $\component{}_2$
 has \emph{stricter} types than $\component{}_1$. Herein, deep is stricter
 than shallow, and shallow is stricter than no types.  Hence, the
 interactions across the target boundary are luckily to lead to run-time
 type checks which impact the performance of the program.  Only after
 figuring out their target boundary, \statkw{} strategies select how to
 modify the components it involves.

 At a second level, basic strategies differ in how they modify the two sides of
 their target boundary. Strategies that are \optkw{} turn the types at
 either side of the boundary to Deep. After all, when two components with
 Deep types interact, no checks take place. Hence, such a modification
 eliminates the cost of the boundary entirely, and may even enable the
 compiler to apply type-driven optimizations to the two components. 
 However, there is a risk or
 a ripple effect: the new Deep types of the two components may increase
 the cost of other boundaries that the two components are involved in. In
 contrast to strategies that are \optkw{}, those that are \conkw{} turn
 the types at either side of the target boundary to shallow. The rationale
 behind this choice is that if both sides of a boundary have
 shallow types, the interactions across the boundary cost less than if
 only one is Deep. At the same time, unlike the  \optkw{}
 strategies,  there is no risk of a ripple effect. 

 Besides the basic strategies, the experiment investigates 9 composite
 strategies (fig. ~\ref{f:cstrategies}). The \costkw{} strategies rank the
 cost of boundaries not just in terms of performance, but also in terms of
 the labor needed to equip then with types.  Hence, they give priority to
 those boundaries that involve components that are laready types.
 Modifying these components boils down to toggling their types form Deep
 to Shallow or the opposite, which is cheap in terms of labor. 
 
 The \confkw{} strategies decide whether to be
 \optkw{} or \conkw{} best on how many components of a program are typed.
 When most components are untyped, the risk of a ripple effect outweighs
 the benefits of the \optkw{} strategy. Therefore strategies favor a
 \conkw{} approach for sparsely typed programs, and an \optkw{} strategy
 for densely typed ones.

 Finally, the experiment includes 2 strategies that are \agnostickw{}.
 Those play the role of experimental baselines: if the profiling
 strategies are more successful than the \agnostickw{} ones, then profiler
 feedback plays a meaningful role in guiding type migration.  The first
 \agnostickw{} strategy, \randkw{}, aims to invalidate the null
 hypothesis: it picks a boundary at random and suggests to its
 rational-programmer mode to modify the target boundary either in an
 \optkw{} or \conkw{} manner.  The second \agnostickw{} strategy,
 \togglekw{}, was proposed by~\citep{g-dsgt} and serves as a point of
 comparison with that previous work that does not employ profilers. If the
 given program has a mixture of Shallow and Deep components, the strategy
 directs its rational-programmer mode to equip all typed components of the
 program with Deep types. If all components are already Deep, it instructs
 the mode to equip all typed components with Shallow types. 

 %% -----------------------------------------------------------------------------
 %% -----------------------------------------------------------------------------
 
 %% -----------------------------------------------------------------------------
\begin{figure}[htb]

  \newcommand{\desc}[1]{\parbox[t]{26em}{#1}}

  \def\desca{\desc{Uses the feature-specific profiler to identify the most
  expensive boundary in the given program. Then it directs the mode to equip
  both sides of the targt boundary with Deep types.}}


  \def\descb{\desc{Same as \featopt{} except that it directs the mode to
  equip both sides of
  the target boundary with Shallow types.}}

  \def\descc{\desc{Uses the statistical profiler to identify the component
  $\component{}_1$  with the highest self time in the given program that
  has a boundary with at least one  component $\component{}_2$ that has
  stricter types than $\component{}_1$.  Then it picks the component
  $\component{}_2$ that has the highest self time, and directs the mode to
  equip both
  $\component{}_1$ and $\component{}_2$ with Deep types.}}

  \def\descd{\desc{Same as \statselfopt{} except that it uses total
  instead of self time.}}


   \def\desce{\desc{Same as \statselfopt{} except that it directs the mode
   to equip 
    $\component{}_1$ and $\component{}_2$
  with Shallow types.}}

   \def\descf{\desc{Same as \statselfcon{} except that it uses total
  instead of self time.}}




   \begin{tabular}{r|l}
    {\bf Strategy Name} & {\bf Description} \\ \hline
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
     \featopt{}          &   \desca          \\ \hline
    \featcon{}          &   \descb           \\ \hline

    \statselfopt{}      &   \descc           \\ \hline
    \stattotalopt{}     &   \descd           \\ \hline
    \statselfcon{}      &   \desce           \\ \hline 
    \stattotalcon{}     &   \descf           
    \end{tabular}

 
  \caption{The Basic Strategies of the Experiment and their Descriptions}
  \label{f:bstrategies}
\end{figure}
%% -----------------------------------------------------------------------------

%% -----------------------------------------------------------------------------
\begin{figure}[htb]
 
  \newcommand{\desc}[1]{\parbox[t]{21.5em}{#1}}

 
  \def\desca{\desc{Splits the boundaries in the given program to those
  between typed components and the rest.  Delegates to \featopt{} to
  produce a modification for an (incomplete) program that consists only of
  components in the first group. If the first group is empty, it resorts
  to the second group.  If the first group is empty, it resorts to the
  second group.}}

   \def\descb{\desc{Same as \featcostopt{} except that it delegates 
   to \featcon{}.}}

   \def\descc{\desc{Separates the typed components   that have boundaries
   with other typed components from the rest of the components in the
   given program. Delegates to \statselfopt{} to produce a modification
   for an (incomplete) program that consists only of components in the
   first group. If the first group is empty, it resorts to the second
   group.}}

   \def\descd{\desc{Same as \statselfcostopt{} except that it delegates 
   to \stattotalopt{}.}}

   \def\desce{\desc{Same as \statselfcostopt{} except that it delegates 
   to \statselfcon{}.}}

   \def\descf{\desc{Same as \statselfcostopt{} except that it delegates 
   to \stattotalcon{}.}}

   \def\descg{\desc{If the number of typed components in the given program 
   is above a threshold $N$, it delegates to \featopt{}. Otherwise, it
   delegates to \featcon{}.}}

    \def\desch{\desc{Same as \featconf{} except that it delegates 
   to \statselfopt{} or \statselfcon{}.}}

    \def\descj{\desc{Same as \featconf{} except that it delegates 
   to \stattotalopt{} or \stattotalcon{}.}}



 \begin{tabular}{r|l}
    {\bf Strategy Name} & {\bf Description} \\\hline
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \featcostopt{}      &   \desca           \\\hline
    \featcostcon{}      &   \descb           \\\hline
  
    \statselfcostopt{}  &   \descc           \\\hline
    \stattotalcostopt{} &   \descd           \\\hline
   \statselfcostcon{}   &   \desce           \\\hline
    \stattotalcostcon{} &   \descf           \\\hline

    \featconf{}         &   \descg           \\\hline
    \statselfconf{}     &   \desch           \\\hline
    \stattotalconf{}    &   \descj           \\
    \end{tabular}

 
  \caption{The Composite Strategies of the Experiment and their Descriptions}
  \label{f:cstrategies}
\end{figure}
%% -----------------------------------------------------------------------------

