%% -----------------------------------------------------------------------------
From the perspective of the experiment, every program \program{} is a
collection of interacting components $\component$. Specifically, some
components have deep types, some  have shallow, and some  have no types at
all. Independently of their types, a component $\component{}_1$, may import
another component $\component{}_2$  which establishes a
\emph{boundary} between them through which they exchange values at
run-time. As section~\ref{sec:seascape} describes, depending on the kind of types at
the two sides of the boundary, a value exchange can result in checks,
which may affect negatively the performance of \program{}. 

 Since boundaries are the source of performance degradation, a profiling
 strategy aims to change the types of components in order to eliminate a
 boundary in a program, hopefully the most costly one. In formal terms, a
 profiling strategy is a function that consumes a program \program{} and
 returns a set of pairs $(\component{}, \type{})$ where \type{} is either
 \deep{} or \shallow{}. Each pair
 prescribes a modification for \program{}. For instance, if a strategy
 returns the singleton set with the pair $(a, \deep)$, then the strategy
 directs its rational-programmer mode to equip component $a$ with deep
 types, or to toggle to deep its existing types, if $a$ is already typed.
 Finally, the strategy returns the empty
 set when it cannot figure out how to proceed.

%% -----------------------------------------------------------------------------

\def\with{with {\em total\/} in place of {\em self\/}}

\begin{figure}[htb]

  \newcommand{\desc}[1]{\parbox[t]{24em}{#1\\[-2mm]}}
  
  \def\desca{\desc{Uses the feature-specific profiler to identify the most
    expensive boundary in the given program. Then it directs the mode to equip
    both sides of the target boundary with Deep types.}}

  \def\descb{\desc{Like \featopt{} but with shallow types for both
    sides of the target boundary.}}

  \def\descc{\desc{Uses the statistical profiler to identify the component
    $\component{}_1$ with the highest self time in the given program that has a
    boundary with at least one component $\component{}_2$ that has stricter
    types than $\component{}_1$.  Then it picks the component $\component{}_2$
    that has the highest self time, and directs the mode to equip both
    $\component{}_1$ and $\component{}_2$ with Deep types.}}

  \def\descd{\desc{Like \statselfopt{} \with}}

  \def\desce{\desc{Like \statselfopt{}, with shallow types for $\component{}_1$, $\component{}_2$}}

  \def\descf{\desc{Like \statselfcon{} with {\em total\/} in place of {\em self\/}}}

 \begin{tabular}{l l l}
    {\bf Profiler} & {\bf Strategy} & {\bf Description} \\ \hline
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \multirow[b]{2}[+5]{*}{{\em feature-specific\/}} & 
        \optkw{}          &   \desca          \\ \relax
     &	\conkw{}          &   \descb          \\ \hline

    \multirow[b]{2}[+7]{*}{{\em statistically\/} ({\em self\/})} &
	\optkw{}      &   \descc          \\ \relax
     &	\conkw{}      &   \desce          \\ \hline

    \multirow{2}{*}{{\em statistically\/} ({\em total\/})} & 
	\conkw{}     &   \descf           \\ \relax
     &	\optkw{}     &   \descd           % \\ \relax
 \end{tabular}

 
  \caption{The Basic Strategies of the Experiment and their Descriptions}
  \label{f:bstrategies}
\end{figure}
%% -----------------------------------------------------------------------------

\paragraph{Basic strategies.}  The experiment compares rational-programmer modes
derived from six basic strategies. Figure~\ref{f:bstrategies} lists them along
with their descriptions.
 At a first level, the basic strategies differ in whether they produce their
 result by analyzing the feedback of a \featkw{} or a \statkw{} profiler.  Those
 that use the first kind of profiler identify directly the most costly boundary
 in \program{}, and produce modifications of the components at either side.
 Those that use the second cannot directly identify a boundary.  Instead they
 detect the most costly component $\component{}_1$ in terms of either \selfkw{}
 or \totalkw{} time.  Then, they pick one of the boundaries between
 $\component{}_1$ and the components it imports or import it.  Specifically, the
 strategies pick a boundary between $\component{}_1$ and a component
 $\component{}_2$ where $\component{}_2$ has \emph{stricter} types than
 $\component{}_1$. Herein, deep is stricter than shallow, and shallow is
 stricter than no types.  Hence, the interactions across the target boundary are
 likely to generate run-time type checks that impact the performance of the
 program.  Only after figuring out their target boundary, \statkw{} strategies
 select how to modify the components it involves.

 At a second level, basic strategies differ in how they modify the two sides of
 their target boundary. Strategies that are \optkw{} turn the types at
 either side of the boundary to Deep. After all, when two components with
 Deep types interact, no checks take place. Hence, such a modification
 eliminates the cost of the boundary entirely, and may even enable the
 compiler to apply type-driven optimizations to the two components. 
 However, there is a risk or
 a ripple effect: the new Deep types of the two components may increase
 the cost of other boundaries that the two components are involved in. In
 contrast to strategies that are \optkw{}, those that are \conkw{} turn
 the types at either side of the target boundary to shallow. The rationale
 behind this choice is that if both sides of a boundary have
 shallow types, the interactions across the boundary cost less than if
 only one is Deep. At the same time, unlike the  \optkw{}
 strategies,  there is no risk of a ripple effect. 

%% -----------------------------------------------------------------------------
\begin{figure}[bt]
 
  \newcommand{\desc}[1]{\parbox[t]{19.5em}{#1\\[-2mm]}}
 
  \def\desca{\desc{Splits the boundaries in the given program to those between
    typed components and the rest.  Delegates to \featopt{} to produce a
    modification for the given program, but rank boundaries in the first group
    higher than those in the second group while determining the most expensive
    boundary.}}

  \def\descb{\desc{Like \featcostopt{} but it delegates to \featcon{}.}}

  \def\descc{\desc{Separates the typed components that have boundaries with
    other typed components from the rest of the components in the given
    program. Delegates to \statselfopt{} to produce a modification for the given
    program, but rank boundaries between components in the first group higher
    than the rest while determining the most expensive boundary.}}

   \def\descd{\desc{Like \statselfcostopt{} but it delegates to \stattotalopt{}.}}

   \def\desce{\desc{Like \statselfcostopt{} but it delegates to \statselfcon{}.}}

   \def\descf{\desc{Like \statselfcostopt{} but it delegates to \stattotalcon{}.}}

   \def\descg{\desc{If the number of typed components in the given program is
     above a threshold $N$, it delegates to \featopt{}. Otherwise, it delegates
     to \featcon{}.}}

   \def\desch{\desc{Like \featconf{}; it delegates to \statselfopt{}
     or \statselfcon{} instead.}}

  \def\descj{\desc{Like \featconf{}; it delegates to \stattotalopt{}
     or \stattotalcon{} instead.}}

 \begin{tabular}{l l l}
    {\bf Profile} & {\bf Strategy Name} & {\bf Description}  \\ \hline
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \multirow[b]{2}[+19]{*}{{\em feature-specific\/}} & 
    \costoptkw{}      &   \desca           \\ \relax
    & \costconkw{}      &   \descb           \\ \relax
    & \confkw{}         &   \descg           \\ \hline

    \multirow[b]{2}[+17]{*}{{\em statistically\/} ({\em self\/})} &
    \costoptkw{}   &   \descc           \\ \relax
    & \costconkw{}   &   \desce           \\ \relax
    & \confkw{}      &   \desch           \\ \hline

    \multirow{2}[+17]{*}{{\em statistically\/} ({\em total\/})} & 
    \costoptkw{} &   \descd           \\ \relax
    & \costconkw{} &   \descf           \\ \relax
    & \confkw{}    &   \descj           % \\ \relax

 \end{tabular}

 
  \caption{The Composite Strategies of the Experiment and their Descriptions}
  \label{f:cstrategies}
\end{figure}
%% -----------------------------------------------------------------------------

\paragraph{Composite strategies.}
 Besides the basic strategies, the experiment investigates nine composite
 strategies (fig. ~\ref{f:cstrategies}). The \costkw{} strategies rank the
 cost of boundaries not just in terms of performance, but also in terms of
 the labor needed to equip then with types.  Hence, they give priority to
 those boundaries that involve components that are already types.
 Modifying these components boils down to toggling their types form Deep
 to Shallow or the opposite, which is cheap in terms of labor. 
 
 The \confkw{} strategies decide whether to be
 \optkw{} or \conkw{} best on how many components of a program are typed.
 When most components are untyped, the risk of a ripple effect outweighs
 the benefits of the \optkw{} strategy. Therefore strategies favor a
 \conkw{} approach for sparsely typed programs, and an \optkw{} strategy
 for densely typed ones.

\paragraph{Null Strategies}

 Finally, the experiment includes two strategies that are \agnostickw{}.
 Those play the role of experimental baselines: if the profiling
 strategies are more successful than the \agnostickw{} ones, then profiler
 feedback plays a meaningful role in guiding type migration.  The first
 \agnostickw{} strategy, \randkw{}, aims to invalidate the null
 hypothesis: it picks at random  a boundary with types of different
 strictness, and suggests to its rational-programmer mode to modify the
 two sides of the target boundary either in an \optkw{} or \conkw{}
 manner.  The second \agnostickw{} strategy, \togglekw{}, was proposed
 by~\citep{g-deep-shallow} and serves as a point of comparison with that previous
 work that does not employ profilers. If the given program has a mixture
 of Shallow and Deep components, the strategy directs its
 rational-programmer mode to equip all typed components of the program
 with Deep types. If all components are already Deep, it instructs the
 mode to equip all typed components with Shallow types. 

