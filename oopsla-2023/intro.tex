 Sound gradual typing promises to support developers while they migrate a
 codebase from an untyped language to a sister typed one.  This promise
 hinges on two points. First, developers pay the labor cost of 
 adding annotations to their code  gradually.  Second, until the
 migration is fully complete, the gradual type system turns some of the
 annotations into checks that monitor for impedance mismatches between the
 annotations and the code's behavior.

 Problem is the run-time type checks are far from cheap.  And gradual type
 systems (and their ecosystems) do not provide any guidance about where
 developers should invest their effort to avoid paying unacceptable
 performance penalties. Hence, developers face a
 conundrum that leads to a natural research question:
 \begin{quote}
 \em How can developers navigate the migration of a code base while keeping
 the performance penalty from run-time checks at acceptable
 levels?\end{quote}  


 In detail, for the so called deep
 checks~\cite{tf-dls-2006,tf-popl-2008,st-sfp-2006}, which use
 higher-order contracts~\cite{ff-icfp-2002} to enforce types, a naive
 placement of annotations can lead to such performance degradation that a
 codebase becomes practically
 unusable~\cite{tfgnvf-popl-2016,gtnffvf-jfp-2019}.  In some cases, if
 type annotations are at the right places in a code base, type-driven
 optimizations may kick in and offset the cost of  contracts elsewhere.  
 But, in general, the addition of just a few type annotations
 at the early stages of migration can lead to a steep slowdown,
 before performance improves eventually with the addition of further
 annotations. 

 An alternative to deep checks are shallow
 checks~\cite{vss-popl-2017,vksb-dls-2014,v-thesis-2019}. They replace
 contracts with the light-weight inspection of the top constructor of a
 value at strategic places in code with annotations.  The effect is a
 pay-as-you go performance penalty: the more annotations a code base has,
 the more profound their impact on performance. In essence, shallow checks
 trade a smooth performance cost at the initial steps of migration for a
 an increasing accumulated cost further down the
 road~\cite{gm-pepm-2018,rmhn-ecoop-2019}.  In other words, the
 performance profile of shallow checks seems to have complementary
 strengths and weaknesses to those of deep checks.  

 Based on this observation, recently
 ~\citet{g-thesis-2020,g-deep-shallow} suggested a combination of checks.
 In principle, developers should be able to mix deep and shallow checks
 to get the maximum type checking benefits with the minimum performance
 penalty.  In fact, Greenman's proposal has been implemented for Typed
 Racket and initial empirical data is promising: with a mixture of checks
 developers can avoid migration paths that result in unacceptable
 slowdowns with either deep or shallow checks alone.  However, the mixture
 of deep and shallow checks makes even harder an already difficult
 practical problem for developers.  In Typed Racket without mixed checks,
 developers have to pick  between the $2^N$ configurations of a program
 with $N$ components --- either a component has type annotations or not
 --- and chart a migration path with acceptable performance along the way
 that leads to a configuration with the desirable amount of type checking.
 In Typed Racket with mixed checks, the size of the space of
 configurations shoots up to $3^N$! 

The key insight of this paper is that profilers can provide the needed guidance to
developers that attempt to navigate the type migration of their code.
But to do so, developers still have to strategically 
translate the feedback from profilers, to migration actions. 
Hence, this paper aims to answer the following: 
\begin{itemize}
  \item    
    {\em How often does profiler feedback help developers
    chart a migration course with acceptable performance?} 
  \item
   {\em Which strategy of interpreting profiler feedback is the most
    successful?}
\end{itemize}   

These questions call for an empirical investigation. To that end, the paper
leverages and adapts the \emph{Rational Programmer}
method~\cite{lksfd-popl-2020,lgfd-icfp-2021}.
While~\citet{lgfd-icfp-2021} have applied successfully the Rational
Programmer to compare the usefulness of shallow and deep checks for
debugging, the context of navigating type migration introduces unique
challenges. First, the method asks for a collection of algorithmic
abstractions, dubbed the rational programmers, that each reifies a
falsifiable hypothesis about a different strategy of interpreting profiler
feedback.  Second, the method relies on the construction of a diverse
population of scenarios that are the starting points for a large-scale
simulation experiment that sets the rational programmers against each
other.    

To sum up, this paper makes two contributions:

\begin{itemize}
  \item At the object level, the results of the rational programmer
    experiment provide guidance to developers about how to use profilers
    during type migration.  
  \item At the meta level, the application of the rational programmer to
    the navigation of type migration provides one more piece of evidence evidence 
    about the extent of the method. 
\end{itemize}    

The remainder of the paper is organized as follows.
Section~\ref{sec:seascape} uses examples to demonstrate how deep
and shallow checks can cause performance bottlenecks during type migration, and how 
profiler feedback
can help developers indentify and mitigate them.  
Section~\ref{sec:ideas} explains how the rational programmer method 
makes it possible to evaluate systematically the effectiveness of
different strategies of interpreting profiler feedback in 
navigating type migration. Section~\ref{sec:experiment} turns these
ideas into a large-scale quantitative experiment. 
Section~\ref{sec:results} presents the results of the experiment, and 
section~\ref{sec:discussion} extracts from these results lessons for PL
researchers and developers. 
Section~\ref{sec:related} places this work in the context of prior
research, and section~\ref{sec:conclusion} puts this work in perspective
with respect to future research on gradual typing. 
