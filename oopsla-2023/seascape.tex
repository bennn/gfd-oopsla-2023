%% -----------------------------------------------------------------------------

Over the years, developers have created many large systems in untyped languages.
In the meantime, language implementers have created gradually typed siblings of
these languages.  Since developers tend to enjoy the benefits of type-based IDE
support and like to type check their code, they are likely to add new components
in the typed sibling language. Alternatively, when a developer is confronted
with debugging an untyped component, it takes a large mental effort to
reconstruct the informal types of its methods, and to make this effort pay off,
it is best to turn the informal types into formal annotations. In either case,
the result is a mixed-typed software system with boundaries between typed and
untyped components. In a sound gradually typed language, these boundaries impose
a performance penalty, possibly a prohibitive one. In the latter case, the
developer faces a performance-debugging scenario.

%% -----------------------------------------------------------------------------
\begin{figure}[htb]

    \bmname{fsm} basics:
    \begin{tabular}{llll}
      81 configurations (cfgs) &
      18 fast &
      5x avg. slowdown &
      3x median slowdown
    \end{tabular}

    \bigskip

    \includegraphics[width=0.9\textwidth]{data/fsm-lattice.pdf}

    after \emph{either-or}~\cite{g-deep-shallow} navigation:
    \begin{tabular}{llll}
      %% 81 - 36
      45 fast cfgs &
      4x avg. slowdown &
      3x median slowdown
    \end{tabular}

  \caption{FILL}
  \label{f:fsm-seascape}
\end{figure}
%% -----------------------------------------------------------------------------

fsm simple benchmark,
benefits from collapsible, better off than object-oriented counterpart fsmoo



TODO x start, y end, per strat, death plot

\begin{itemize}
  \item This section should present a mix-typed example. It would be good
    if the example is straight from the benchmarks, but, if this is not
    manageable, it can also be a distilled or altered version.  The basic
    requirement is that it runs and exhibits slowdown over the untyped
    version with its currrent types. In addition, some of its types should
    be shallow and some deep to set up the discussion about the
    semantics.
  \item Following the description of the example,  
    the section should explain how the program evaluates and connect that with the
    semantics of shallow and deep types. 
  \item Next, the section should describe the feedback from the statistical
    profiler, introduce the boundary profiler  and 
    describe its feedback too. 
  \item As the feedback of each profiler is shown, the section should 
    explain that it provides hints about where to look for
    possible improvements. It would be great, if the section shows how
    actin on two hints plays out.  
  \item As a final piece, the section should discuss that the
    interpretation
    of the feedback to hints is two dimentional (identify component and
    identify change to component), and that how a developer can itnerepret
    it reliably needs a careful and systematic look.
\end{itemize}


The section does not need to talk about whether this or that strategy is
succesful, nor it needs to bring accross the specifics of one or more
strategies. It's goal is to provide background, build some intuition about
profilers and the usefulnes of the their feedbacks, and give a concrete view of
 the complexity of interpreting hints.

