%% -----------------------------------------------------------------------------

Over the years, developers have created many large systems in untyped languages.
In the meantime, language implementers have created gradually typed siblings of
these languages.  Since developers tend to enjoy the benefits of type-based IDE
support and like to type check their code, they are likely to add new components
in the typed sibling language. Alternatively, when a developer is confronted
with debugging an untyped component, it takes a large mental effort to
reconstruct the informal types of its methods, and to make this effort pay off,
it is best to turn the informal types into formal annotations. In either case,
the result is a mixed-typed software system with boundaries between typed and
untyped components. In a sound gradually typed language, these boundaries impose
a performance penalty, possibly a prohibitive one. In the latter case, the
developer faces a performance-debugging scenario.

CITE snapl

NEXT UP: config, add one type, profiler data what to do?
 boundary non-boundary
 WHAT PROFILE DO YOU ACTUALLY GET
 2 profiler options, for each get several

\begin{itemize}
  \item This section should present a mix-typed example. It would be good
    if the example is straight from the benchmarks, but, if this is not
    manageable, it can also be a distilled or altered version.  The basic
    requirement is that it runs and exhibits slowdown over the untyped
    version with its currrent types. In addition, some of its types should
    be shallow and some deep to set up the discussion about the
    semantics.
  \item Following the description of the example,  
    the section should explain how the program evaluates and connect that with the
    semantics of shallow and deep types. 
  \item Next, the section should describe the feedback from the statistical
    profiler, introduce the boundary profiler  and 
    describe its feedback too. 
  \item As the feedback of each profiler is shown, the section should 
    explain that it provides hints about where to look for
    possible improvements. It would be great, if the section shows how
    actin on two hints plays out.  
  \item As a final piece, the section should discuss that the
    interpretation
    of the feedback to hints is two dimentional (identify component and
    identify change to component), and that how a developer can itnerepret
    it reliably needs a careful and systematic look.
\end{itemize}


The section does not need to talk about whether this or that strategy is
succesful, nor it needs to bring accross the specifics of one or more
strategies. It's goal is to provide background, build some intuition about
profilers and the usefulnes of the their feedbacks, and give a concrete view of
 the complexity of interpreting hints.


%% -----------------------------------------------------------------------------
\begin{figure}[htb]

  \bmname{fsm} basics:
  \begin{tabular}{llll}
    81 configurations (cfgs) &
    18 fast &
    5x avg. slowdown &
    3x median slowdown
  \end{tabular}

  \bigskip

  \includegraphics[width=0.9\textwidth]{data/fsm-lattice.pdf}

  after \emph{either-or}~\cite{g-deep-shallow} navigation:
  \begin{tabular}{llll}
    %% 81 - 36
    45 fast cfgs &
    4x avg. slowdown &
    3x median slowdown
  \end{tabular}

  \caption{Performance lattices for \bmname{fsm}, before and after a simple navigation.}
  \label{f:fsm-seascape}
\end{figure}
%% -----------------------------------------------------------------------------

FILL various approaches to GT,
erasure unsound,
concrete inflexible (even with Static Python's transient mix),
transient not a complete monitor.

For gradual type systems that provide deep type guarantees,
performance is a major challenge.
Despite recent advances~(\cref{sec:related}), adding types to part of a program
is likely to add significant run-time costs.
These costs might be as low as 2x slower than the untyped code, but, depending
on the system at hand, could be 10x or much more~[CITE].

FILL deep, shallow, untyped world

In this paper, we take the position that \emph{any overhead} is unacceptable.
Unless gradually typed code runs at least as fast as the untyped code
(i.e., a 1x slowdown), it is too slow.

The challenge, then, is to \emph{navigate} from an arbitrary starting point
to a fast partially-typed program.
Navigation cannot remove types.
If removal was allowed, then the problem would have a trivial solution: revert
to the untyped code.
Instead, navigation proceeds in one of four ways:
\begin{enumerate}
  \item
    Add Deep types to an untyped component.
  \item
    Add Shallow types to an untyped component.
  \item
    Strengthen the types in a Shallow-typed component.
  \item
    Weaken the types in a Deep-typed component.
\end{enumerate}

Finding a fast configuration is easier said than done.
The space of gradually-typed configurations is huge, even for
small programs, and the fast configurations may be hard to find.
\Cref{f:fsm-seascape} illustrates the problem for one
rather small and fast program from the GTP benchmark suite~[CITE].
This program, \bmname{fsm}, has four modules and thus 81 configurations.

FILL


In practice, a programming team can always remove types to recover performance.
For example: experiment with gradual types on a side branch, outside the main
development, and keep them out until the gradually-typed variant runs as fast
as the main branch.
The question still remains as to when or if the gradually-typed code will be
fast enough.
This paper investigates strategies to reduce the effort.


