%% -----------------------------------------------------------------------------

Over the years, developers have created many large systems in untyped languages.
In the meantime, language implementers have created gradually typed siblings.
Since developers tend to enjoy the benefits of IDE support via types and prefer
type checking, they can, and likely will, add new components in the typed
sibling language. Alternatively, when a developer is confronted with debugging
an untyped component, the mental effort of reconstructing the informal types of
methods and functions will have an even larger payoff if the component is
annotated with types. The result is a mixed-typed software system, with a
typed-untyped boundary that imposes a performance penalty---and possibly a
prohibitive one. Regardless of how the boundary came about, the developer now
faces a performace-debugging scenario. 

%% -----------------------------------------------------------------------------
\begin{figure}[htb]

    \bmname{fsm} basics:
    \begin{tabular}{llll}
      81 configurations (cfgs) &
      18 fast &
      5x avg. slowdown &
      3x median slowdown
    \end{tabular}

    \bigskip

    \includegraphics[width=0.9\textwidth]{data/fsm-lattice.pdf}

    after \emph{either-or}~\cite{g-deep-shallow} navigation:
    \begin{tabular}{llll}
      %% 81 - 36
      45 fast cfgs &
      4x avg. slowdown &
      3x median slowdown
    \end{tabular}

  \caption{FILL}
  \label{f:fsm-seascape}
\end{figure}
%% -----------------------------------------------------------------------------

fsm simple benchmark,
benefits from collapsible, better off than object-oriented counterpart fsmoo



TODO x start, y end, per strat, death plot

\begin{itemize}
  \item This section should present a mix-typed example. It would be good
    if the example is straight from the benchmarks, but, if this is not
    manageable, it can also be a distilled or altered version.  The basic
    requirement is that it runs and exhibits slowdown over the untyped
    version with its currrent types. In addition, some of its types should
    be shallow and some deep to set up the discussion about the
    semantics.
  \item Following the description of the example,  
    the section should explain how the program evaluates and connect that with the
    semantics of shallow and deep types. 
  \item Next, the section should describe the feedback from the statistical
    profiler, introduce the boundary profiler  and 
    describe its feedback too. 
  \item As the feedback of each profiler is shown, the section should 
    explain that it provides hints about where to look for
    possible improvements. It would be great, if the section shows how
    actin on two hints plays out.  
  \item As a final piece, the section should discuss that the
    interpretation
    of the feedback to hints is two dimentional (identify component and
    identify change to component), and that how a developer can itnerepret
    it reliably needs a careful and systematic look.
\end{itemize}


The section does not need to talk about whether this or that strategy is
succesful, nor it needs to bring accross the specifics of one or more
strategies. It's goal is to provide background, build some intuition about
profilers and the usefulnes of the their feedbacks, and give a concrete view of
 the complexity of interpreting hints.

