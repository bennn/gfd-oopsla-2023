
The working programmer does not know the complete migration lattice. 

For a program with a handful of components, a programmer should randomly
add types or toggle all existing types until the performance is tolerable.
Other than in those cases, shallow type enforcement does not seem to
offer any advantages. 

In case, a programmer thinks that a large mixed-typed program exhibits
intolerable performance, it is time to reach for the boundary profiler.
Furthermore, when the boundary profiler is able to identify a particular
as a cause of the bad performance, the programmer is best served by
converting both sides of the boundary to use deep types. In support of
this argument, the programmer can safely ignore assessing any
characterestic of the program or the migration step; the blindly oprimistic  

If a programmer uses the boundary profiler with an optimistic approach,
and the result is a performance degradation, then it is unlikely that any
of strategies presented here will help debug the performance problem. 


% How successful is a strategy $X$ with the elimination of performance bottlenecks?

$Q_X$

- level 1: any optimistic or cost-aware strategy is more likely to
  succeed than a conservative one; indeed, random and toggling are
  more likely to succeed than conservative one

- level 2: when feedback is successful, the boundary profiler
  is far superior to all others. That's true in general as well as 

- level 1: interpreting the feedback from the boundary
  profiler is more likely to succeed than 

%% -----------------------------------------------------------------------------

% Is strategy $X$ more successful than strategy $Y$ in this context?

$Q_{X/Y}$

%% -----------------------------------------------------------------------------
\subsection{Threats to Validity}


Threats to validity:

internal
————
benchmarks 
profiler limitations, especially the boundary one — see classes
typing one module at a time — maybe splitting modules is best


external
—————
one language 
real programmers may not have access to libraries etc or may not be programmers 



``black holes''
